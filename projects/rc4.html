<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RC4 Decryption on FPGA</title>
  <link rel="stylesheet" href="/style.css">
</head>
<body>
  <h1>RC4 Decryption on FPGA</h1>

  <p>
    <a href="https://github.com/AveryWong03/RC4_Decryption"><strong>Github Link</strong></a>
  </p>

  <p style="display: flex; align-items: center; gap: 8px; color: #eda0a0; font-size: 24px;">
    <span style="font-weight: bold;">Tags:</span>
    <label>FPGA</label>
    <label>Quartus</label>
    <label>SystemVerilog</label>
  </p>

  <p style="opacity: 0.5;">
    As a part of my digital design class, we were tasked with implementing an RC4 decryption algorithm on an FPGA. 
    This was my solution to the task!
  </p>

  <h2>Learnings Summary</h2>
  <p>
    From this project, I learned how to implement a software algorithm in hardware, which involved writing FSMs, configuring and using memory IP, and learning about handshaking protocols.
  </p>

  <h2>An Introduction to RC4</h2>
  <p>
    RC4 or Rivest Cipher 4 is a simple stream cipher that uses a key and bitwise XOR to encrypt and decrypt messages. 
    The pseudocode algorithm for RC4 decryption is given below.
  </p>

  <pre><code>
// Input:
// secret_key [] : array of bytes that represent the secret key
// encrypted_input []: array of bytes that represent the encrypted message
// Output:
// decrypted_output []: array of bytes that represent the decrypted result.

for i = 0 to 255 {
  s[i] = i;
}
// shuffle the array based on the secret key
j = 0
for i = 0 to 255 {
  j = (j + s[i] + secret_key[i mod keylength]) mod 256
  swap values of s[i] and s[j]
}
// compute one byte per character in the encrypted message.
i = 0, j = 0
for k = 0 to message_length-1 {
  i = (i+1) mod 256
  j = (j+s[i]) mod 256
  swap values of s[i] and s[j]
  f = s[(s[i]+s[j]) mod 256]
  decrypted_output[k] = f xor encrypted_input[k] // 8-bit wide XOR function
}</code></pre>

  <p>
    For this project, we were given an encrypted input and were tasked with brute force solving for the secret key. 
    That is, we would increment through keys and evaluate if the decrypted output contained a legible message by checking that each byte was a valid ASCII character.
  </p>

  <h2>The Design</h2>
  <p>
    Below is a rough block diagram for the FSMs that I implemented.
  </p>

  <img src="/assets/img/rc4/fsms.jpg" alt="FSM block diagram">

  <p>
    Here, there is a key handler that increments the keys and handles key distribution given multiple decryption cores (not pictured but was implemented for parallelized computation), a core that runs the three for loops in the algorithm, and a memory handler that handles requests to working memory.
  </p>

  <p>
    There are also three instantiated memory IPs: a ROM to store the encrypted message, a RAM to store the eventual decrypted message, and the working memory (RAM) that is used during the algorithm.
  </p>

  <h2>Verification</h2>
  <p>
    All of the loop FSMs were verified using both Quartus waveform simulator and Quartus SignalTap (real-time signal viewer). 
    These do get a bit messy but were a huge help with debugging and verifying the functionality of the FSMs.
  </p>

  <img src="/assets/img/rc4/simulationveriffsm.jpg" alt="Simulation verification for fsm_loop_1">
  <p class="caption">Simulation verification for fsm_loop_1</p>

  <img src="/assets/img/rc4/signaltap.jpg" alt="SignalTap verification for fsm_loop_1">
  <p class="caption">SignalTap verification for fsm_loop_1</p>

  <h2>Results</h2>
  <p>
    The below image shows the three instantiated memory IPs, S being the working memory, M being the encrypted message, and D being the decrypted message, which was 
    <em>“rc four is not very secure”</em>.
  </p>

  <img src="/assets/img/rc4/works.png" alt="Decryption result memory IPs">

  <p>
    Code from a previous project was also used to display the secret key that was found.
  </p>

  <img src="/assets/img/key.png" alt="Recovered secret key">
</body>
</html>
